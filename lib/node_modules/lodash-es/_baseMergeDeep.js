'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _assignMergeValue = require('./_assignMergeValue.js');
var _cloneBuffer = require('./_cloneBuffer.js');
var _cloneTypedArray = require('./_cloneTypedArray.js');
var _copyArray = require('./_copyArray.js');
var _initCloneObject = require('./_initCloneObject.js');
var isArguments = require('./isArguments.js');
var isArray = require('./isArray.js');
var isArrayLikeObject = require('./isArrayLikeObject.js');
var isBuffer = require('./isBuffer.js');
var isFunction = require('./isFunction.js');
var isObject = require('./isObject.js');
var isPlainObject = require('./isPlainObject.js');
var isTypedArray = require('./isTypedArray.js');
var _safeGet = require('./_safeGet.js');
var toPlainObject = require('./toPlainObject.js');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet.default(object, key),
      srcValue = _safeGet.default(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue.default(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray.default(srcValue),
        isBuff = !isArr && isBuffer.default(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray.default(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray.default(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject.default(objValue)) {
        newValue = _copyArray.default(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer.default(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray.default(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject.default(srcValue) || isArguments.default(srcValue)) {
      newValue = objValue;
      if (isArguments.default(objValue)) {
        newValue = toPlainObject.default(objValue);
      }
      else if (!isObject.default(objValue) || isFunction.default(objValue)) {
        newValue = _initCloneObject.default(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue.default(object, key, newValue);
}

exports.default = baseMergeDeep;
